// Generated by CoffeeScript 1.9.3
(function() {
  'use strict';
  var BrowserWindow, Channel, Menu, Q, Tray, User, app, appIcon, async, close, config, contextMenu, currStreamers, dialog, exec, followed, fs, getChannelStatus, getFollowed, ipc, loadData, mainWindow, minutes, notifier, notifyNewStreamer, openSettings, openSetup, openStream, path, prevStreamers, request, setupWindow, streamWindow, streamerIsAlreadyOnline, the_interval, tick, user;

  app = require('app');

  BrowserWindow = require('browser-window');

  Menu = require('menu');

  Tray = require('tray');

  request = require('request');

  async = require('async');

  path = require('path');

  exec = require('child_process').exec;

  fs = require('fs');

  User = require('./models/user.js');

  Q = require('q');

  Channel = require('./models/channel.js');

  followed = [];

  currStreamers = [];

  prevStreamers = [];

  mainWindow = null;

  appIcon = null;

  user = null;

  minutes = .5;

  the_interval = minutes * 60 * 1000;

  config = {};

  setupWindow = {};

  loadData = function(err, data) {
    var username;
    if (!err) {
      config = JSON.parse(data);
      username = config.user;
      if (username) {
        user = new User(username);
        console.log('user:', user);
        tick();
        return setInterval(function() {
          if (user) {
            return tick();
          }
        }, the_interval);
      } else {
        return openSetup();
      }
    } else {
      return console.log('Error reading configuration:', err);
    }
  };

  getFollowed = function(user, cb) {
    followed = [];
    return request("https://api.twitch.tv/kraken/users/" + user + "/follows/channels", function(error, response, body) {
      var data, streamer;
      if (!error) {
        data = JSON.parse(body);
        if (data) {
          followed = (function() {
            var i, len, ref, results1;
            ref = data.follows;
            results1 = [];
            for (i = 0, len = ref.length; i < len; i++) {
              streamer = ref[i];
              results1.push({
                streamName: streamer.channel.name,
                displayName: streamer.channel.display_name
              });
            }
            return results1;
          })();
          return cb();
        }
      }
    });
  };

  getChannelStatus = function(channel, callback) {
    console.log('get channel status', channel, callback);
    return request("https://api.twitch.tv/kraken/streams/" + channel.streamName, function(error, response, body) {
      var err, stream;
      if (!error) {
        stream = {};
        try {
          stream = JSON.parse(body).stream;
        } catch (_error) {
          err = _error;
          console.log('Error parsing json:', err);
          stream = null;
          callback(err);
        }
        if (stream && currStreamers.indexOf(channel) === -1) {
          currStreamers.push(channel);
        }
        return callback();
      } else {
        console.log('error:', error);
        return callback(error);
      }
    });
  };

  contextMenu = {};

  tick = function() {
    prevStreamers = [];
    console.log('user:', user);
    return user.getFollowed().then(function(results) {
      var streamer;
      console.log('Got async followed:', results);
      prevStreamers = (function() {
        var i, len, results1;
        results1 = [];
        for (i = 0, len = currStreamers.length; i < len; i++) {
          streamer = currStreamers[i];
          results1.push(streamer.streamName);
        }
        return results1;
      })();
      currStreamers = [];
      return async.each(results, function(channel, callback) {
        var currChannel;
        console.log('async.each', channel, Channel);
        currChannel = new Channel(channel.streamName, channel.displayName);
        console.log('channel:', currChannel);
        return currChannel.onlineStatus().then(function(stream) {
          if (stream) {
            console.log('stream:', stream);
          }
          if (stream) {
            currStreamers.push(stream);
          }
          return callback();
        });
      }, function(err) {
        var fn, i, j, labels, len, len1, results1, selectedStreamer;
        if (!err) {
          selectedStreamer = null;
          labels = [];
          console.log('currstreamers:', currStreamers.length, currStreamers);
          fn = function(currStreamer) {
            console.log('the streamer label:', currStreamer.display_name);
            return labels.push({
              label: currStreamer.display_name,
              type: 'normal',
              click: function() {
                return openStream(currStreamer);
              }
            });
          };
          for (i = 0, len = currStreamers.length; i < len; i++) {
            streamer = currStreamers[i];
            console.log('STREAMER::', streamer);
            fn(streamer.channel);
          }
          appIcon.setToolTip('Online streamers');
          if (currStreamers.length === 0) {
            appIcon.setImage(path.join(__dirname, 'img/dota2_gray.jpg'));
            labels.push({
              label: 'No live streams',
              type: 'normal'
            });
          } else {
            appIcon.setImage(path.join(__dirname, 'img/dota2.png'));
          }
          labels.push({
            label: 'Commands',
            type: 'separator'
          });
          labels.push({
            label: 'Settings',
            type: 'normal',
            click: openSettings
          });
          labels.push({
            label: 'Quit',
            type: 'normal',
            click: 'close'
          });
          console.log('labels:', labels);
          contextMenu = Menu.buildFromTemplate(labels);
          appIcon.setContextMenu(contextMenu);
          results1 = [];
          for (j = 0, len1 = currStreamers.length; j < len1; j++) {
            streamer = currStreamers[j];
            if (!streamerIsAlreadyOnline(streamer)) {
              results1.push(notifyNewStreamer(streamer));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        } else {
          return console.log('an error!', err);
        }
      });
    });
  };

  streamerIsAlreadyOnline = function(streamer) {
    console.log('checking streamer:', streamer, prevStreamers, prevStreamers.indexOf(streamer.streamName) === !-1);
    return prevStreamers.indexOf(streamer.streamName) > -1;
  };

  streamWindow = null;

  openStream = function(streamer) {
    console.log('open stream', streamer);
    return exec("/usr/local/bin/livestreamer twitch.tv/" + streamer.streamName + " best", function(error, stdout, stderr) {
      if (error) {
        return console.log('exec error: #{error}');
      }
    });
  };

  dialog = require('dialog');

  ipc = require('ipc');

  openSetup = function() {
    var setupUrl;
    console.log('open setup');
    setupWindow = new BrowserWindow({
      width: 800,
      height: 600,
      show: true
    });
    setupUrl = path.join('file://', __dirname, 'setup.html');
    console.log('setup url:', setupUrl);
    setupWindow.loadUrl(setupUrl);
    return ipc.on('saveSetup', function(event, arg) {
      var username;
      if (arg) {
        username = arg;
        config.user = username;
        user = new User(username);
        console.log('new user:', user);
        fs.writeFile(path.join(__dirname, '/config.json'), JSON.stringify(config), function(err) {
          if (err) {
            throw err;
          }
        });
        if (setupWindow) {
          setupWindow.close();
        }
        setupWindow = null;
        tick();
        return setInterval(function() {
          if (username) {
            return tick();
          }
        }, the_interval);
      }
    });
  };

  openSettings = function() {
    var pageURL;
    streamWindow = new BrowserWindow({
      width: 800,
      height: 600,
      show: true
    });
    pageURL = path.join('file://', __dirname, '/settings.html');
    streamWindow.loadUrl(pageURL);
    streamWindow.webContents.on('did-finish-load', function() {
      return streamWindow.webContents.send('username', username);
    });
    return ipc.on('saveSettings', function(event, arg) {
      var username;
      if (arg) {
        username = arg;
        config.user = username;
        user = new User(username);
        fs.writeFile(path.join(__dirname, 'config.json'), JSON.stringify(config), function(err) {
          if (err) {
            throw err;
          }
        });
        if (streamWindow) {
          streamWindow.close();
        }
        streamWindow = null;
        prevStreamers = [];
        currStreamers = [];
        return tick();
      }
    });
  };

  app.on('ready', function() {
    console.log('app is ready');
    fs.readFile(path.join(__dirname, 'config.json'), loadData);
    return appIcon = new Tray(path.join(__dirname, 'img/dota2_gray.jpg'));
  });

  notifier = require('node-notifier');

  notifyNewStreamer = function(streamer) {
    console.log('NOTIFY', streamer);
    return notifier.notify({
      title: 'Now Online',
      message: streamer.channel.display_name,
      icon: path.join(__dirname, 'img/dota2.png')
    });
  };

  close = function() {
    streamWindow = null;
    appIcon.destroy();
    return process.exit(0);
  };

}).call(this);
